/* SPDX-License-Identifier: GPL-2.0 */

/* Copyright 2019-2023 Hewlett Packard Enterprise Development LP */

#ifndef _SBL_PML_FN_H_
#define _SBL_PML_FN_H_

/* min time to bring up pml block */
#define SBL_PML_MIN_START_TIME                2 /* s */

/* pcs alignment */
#define SBL_PML_PCS_ALIGN_TIMEOUT          1000 /* ms */
#define SBL_PML_PCS_ALIGN_SLOW_POLL_DELAY  1000 /* ms */

/* number of times we see no fault to decide pcs is up */
#define SBL_PML_REQUIRED_NO_FAULT_COUNT       2

/* number of llr timing measurements required */
#define SBL_PML_LLR_TIMING_LOOPS              10

/* delay for llr measurement to complete (us) */
#define SBL_PML_LLR_TIMING_MEASURE_DELAY      50

/* llr capacity calc nums */
#define SBL_PML_LLR_MIN_LOOP_TIME       60ULL /* ns per spec                 */
#define SBL_PML_LLR_MAX_LOOP_TIME     3000ULL /* ns max 100m cable           */
#define SBL_PML_LLR_NUM_FRAMES           2ULL /* frame multiplier            */

/* delay after unsuccessful measurement attempt (ms) */
#define SBL_PML_LLR_TIMING_PERIOD        2000ULL /* ns for 200m */
#define SBL_PML_LLR_TIMING_RETRY_DELAY       200

/* LLR detect timing */
#define SBL_PML_LLR_DETECT_DELAY    100 /* ms */
#define SBL_PML_LLR_DETECT_TIMEOUT 1000 /* ms */

/* LLR options */
#define SBL_PML_LLR_OPTION_HPC_WIH_LLR (1<<0)

/* Max number of Physical Lanes available on Tx/Rx */
#define MAX_PLS_AVAILABLE 0xF

/* Timeout for Health Markers. We'll surely receive health markers in 100 us, if any */
#define HM_TIMEOUT 100

/* the PML error flags that can be generated by the various blocks */
#define SBL_PML_ALL_PCS_ERR_FLGS              0x0001fff800000000ULL
#define SBL_PML_ALL_MAC_ERR_FLGS              0x0006000000000000ULL
#define SBL_PML_ALL_LLR_ERR_FLGS              0x1ff8000000000000ULL


/* PML error flags monitored during autoneg */
#define SBL_AUTONEG_ERR_FLGS	 (SBL_PML_ERR_FLG_AUTONEG_COMPLETE_SET(1ULL) | \
				  SBL_PML_ERR_FLG_AUTONEG_PAGE_RECEIVED_SET(1ULL))

/* PML error flags monitored for link faults */
#define SBL_PML_FAULT_ERR_FLAGS		(SBL_PML_ERR_FLG_PCS_LINK_DOWN_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_HI_SER_SET(1ULL) | \
					 SBL_PML_ERR_FLG_LLR_REPLAY_AT_MAX_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_TX_DEGRADE_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_RX_DEGRADE_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_TX_DEGRADE_FAILURE_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_RX_DEGRADE_FAILURE_SET(1ULL))

#define SBL_PML_REC_FAULT_ERR_FLAGS	(SBL_PML_ERR_FLG_PCS_LINK_DOWN_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_HI_SER_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_TX_DEGRADE_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_RX_DEGRADE_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_TX_DEGRADE_FAILURE_SET(1ULL) | \
					 SBL_PML_ERR_FLG_PCS_RX_DEGRADE_FAILURE_SET(1ULL))

/* general PML */
int  sbl_pml_start(struct sbl_inst *sbl, int port_num);
int  sbl_pml_link_down(struct sbl_inst *sbl, int port_num);
void sbl_pml_set_defaults(struct sbl_inst *sbl, int port_num);
bool sbl_pml_err_flgs_test(struct sbl_inst *sbl, int port_num, u64 err_flgs);
void sbl_pml_err_flgs_clear(struct sbl_inst *sbl, int port_num, u64 err_flgs);
void sbl_pml_err_flgs_clear_all(struct sbl_inst *sbl, int port_num);
void sbl_pml_link_down_async_alert(struct sbl_inst *sbl, int port_num, u32 down_origin);

/* interrupts */
int sbl_pml_install_intr_handler(struct sbl_inst *sbl, int port_num, u64 err_flags);
int sbl_pml_enable_intr_handler(struct sbl_inst *sbl, int port_num, u64 err_flags);
int sbl_pml_disable_intr_handler(struct sbl_inst *sbl, int port_num, u64 err_flags);
int sbl_pml_remove_intr_handler(struct sbl_inst *sbl, int port_num);

/* PCS */
int   sbl_pml_pcs_am_start(struct sbl_inst *sbl, int port_num);
bool  sbl_pml_pcs_high_serdes_error(struct sbl_inst *sbl, int port_num);
bool  sbl_pml_pcs_up(struct sbl_inst *sbl, int port_num);
void  sbl_pml_pcs_enable_alignment(struct sbl_inst *sbl, int port_num);
void  sbl_pml_pcs_disable_alignment(struct sbl_inst *sbl, int port_num);
int   sbl_pml_pcs_wait(struct sbl_inst *sbl, int port_num);
void  sbl_pml_pcs_start(struct sbl_inst *sbl, int port_num);
void  sbl_pml_pcs_stop(struct sbl_inst *sbl, int port_num);
void  sbl_pml_pcs_ordered_sets(struct sbl_inst *sbl, int port_num, int enable);
void  sbl_pml_pcs_set_tx_rf(struct sbl_inst *sbl, int port_num);
void  sbl_pml_pcs_clear_tx_rf(struct sbl_inst *sbl, int port_num);
char *sbl_pml_pcs_state_str(struct sbl_inst *sbl, int port_num, char *buf, int len);
void  sbl_pml_pcs_enable_auto_lane_degrade(struct sbl_inst *sbl, int port_num);
bool  sbl_pml_rx_pls_available(struct sbl_inst *sbl, int port_num);
bool  sbl_pml_lp_pls_available(struct sbl_inst *sbl, int port_num);
bool  sbl_pml_recovery_no_faults(struct sbl_inst *sbl, int port_num);
void  sbl_pml_recovery_log_pcs_status(struct sbl_inst *sbl, int port_num);

/* MAC */
int  sbl_pml_mac_config(struct sbl_inst *sbl, int port_num);
void sbl_pml_mac_hw_status(struct sbl_inst *sbl, int port_num, bool *tx_op,
		bool *rx_op, u32 *ifg_mode, u32 *ifg_adjustment);
void sbl_pml_mac_hpc_set(struct sbl_inst *sbl, int port_num);

/* LLR */
void sbl_pml_llr_config(struct sbl_inst *sbl, int port_num);
int  sbl_pml_llr_start(struct sbl_inst *sbl, int port_num);
u64  sbl_pml_llr_link_down_behaviour(struct sbl_inst *sbl, int port_num);

/* TODO: update the values below to reflect changes in the draft
 * standard
 */
#define SBL_PCS_200_CM                        0xD6D9B56505264A9A
#define SBL_PCS_200_UM0                         0x733F4C298CC0B3
#define SBL_PCS_200_UM1                         0x8121A5987EDE5A
#define SBL_PCS_200_UM2                         0xA90CC10156F33E
#define SBL_PCS_200_UM3                         0x2F7F797BD08086
#define SBL_PCS_200_UM4                         0x0DAED5E6F2512A
#define SBL_PCS_200_UM5                         0x2EB0EDB1D14F12
#define SBL_PCS_200_UM6                         0x5E63BD11A19C42
#define SBL_PCS_200_UM7                         0xA48929CD5B76D6
#define SBL_PCS_200_CM_MATCH_MSK                          0x3F3F
#define SBL_PCS_200_UM_MATCH_MSK                          0x3F3F


#endif  /* _SBL_PML_FN_H_ */
